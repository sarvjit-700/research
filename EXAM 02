STR CMP
if s1 == s2
continue, else
use return unsigned char - unsigned char

STR DUP
same as copy STRCPY but with malloc
find length

STR CAP
keep all the spaces
if its the first char or prev was a space/tab then UPP
if not the first or space/tab and is UPP then make LOW
otherwise write


LASTWORD
go to the end of string and work backwards
go back all spaces and then all continue going back until next space
start loop from there and write until space


CAMEL TO SNAKE
search for UPP letters
write '_' 
write LC letters

SNAKE TO CAMEL
loop through until '_'
move to next char and make UPP
otherwise just print

EPUR and EXPAND
use a flag to know when there are spaces
when spaces have passed check flag to see if space needs to be written

ALPHA MIRROR
for UPP use (A - s1[i]) + Z

ROT
keep it simple, make a specific rule for Z, z.
rest just + 1.

HIDENP
check both strings for '\0'
if s1 = s2 move on in s1, otherwise move on in s2
if s1 reaches '\0' it means all letters werew found write 1, else 0

INTER
remember if(checkdbls(s1, s1[i], index)) == 1
in checkdbls use (i < index) if s1 = c, return 0, else 1

UNION
join both strings s1, s2 into s1, then do checkdbls

flood fill / split

STRREV
only allowed to use the same string, use a temp char c
while (end > start)

REV_WSTR
use i find length of whole string and set end point
in the loop while i is not 0 
 from now always set end based on i is 0 or in spaces
 set start of word when not a space
loop start to end and print
if i is not -1 then print space




